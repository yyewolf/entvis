// Code generated by ent, DO NOT EDIT.

package ent

import "log"

type (
	admin  struct{}
	public struct{}
	self   struct{}
)

var (
	Admin  = admin{}
	Public = public{}
	Self   = self{}
)

type CardRoles interface {
	admin | public | self
}

func ViewCardAs[K CardRoles](c *Card, role K) *Card {
	if c == nil {
		return nil
	}

	switch any(role).(type) {
	case admin:
		return &Card{
			Edges: CardEdges{
				OwnedBy:             ViewUserAs(c.Edges.OwnedBy, role),
				FavedUsers:          ViewUserListAs(c.Edges.FavedUsers, role),
				PlayerFavoriteCards: ViewPlayerFavoriteCardsListAs(c.Edges.PlayerFavoriteCards, role),
			},
		}
	case public:
		return &Card{
			Edges: CardEdges{
				OwnedBy:             ViewUserAs(c.Edges.OwnedBy, role),
				FavedUsers:          ViewUserListAs(c.Edges.FavedUsers, role),
				PlayerFavoriteCards: ViewPlayerFavoriteCardsListAs(c.Edges.PlayerFavoriteCards, role),
			},
		}
	case self:
		return &Card{
			Edges: CardEdges{
				OwnedBy:             ViewUserAs(c.Edges.OwnedBy, role),
				FavedUsers:          ViewUserListAs(c.Edges.FavedUsers, role),
				PlayerFavoriteCards: ViewPlayerFavoriteCardsListAs(c.Edges.PlayerFavoriteCards, role),
			},
		}
	default:
		log.Fatalf("role not found to view Card as %T", role)
	}

	return nil
}

func ViewCardListAs[K CardRoles](c []*Card, role K) []*Card {
	if len(c) == 0 {
		return nil
	}
	views := make([]*Card, len(c))
	for i, v := range c {
		views[i] = ViewCardAs(v, role)
	}
	return views
}

type LightRoles interface {
	admin | public | self
}

func ViewLightAs[K LightRoles](l *Light, role K) *Light {
	if l == nil {
		return nil
	}

	switch any(role).(type) {
	case admin:
		return &Light{
			PrivateField: l.PrivateField,
		}
	case public:
		return &Light{}
	case self:
		return &Light{
			PrivateField: l.PrivateField,
		}
	default:
		log.Fatalf("role not found to view Light as %T", role)
	}

	return nil
}

func ViewLightListAs[K LightRoles](l []*Light, role K) []*Light {
	if len(l) == 0 {
		return nil
	}
	views := make([]*Light, len(l))
	for i, v := range l {
		views[i] = ViewLightAs(v, role)
	}
	return views
}

type PlayerFavoriteCardsRoles interface {
	admin | public | self
}

func ViewPlayerFavoriteCardsAs[K PlayerFavoriteCardsRoles](pfc *PlayerFavoriteCards, role K) *PlayerFavoriteCards {
	if pfc == nil {
		return nil
	}

	switch any(role).(type) {
	case admin:
		return &PlayerFavoriteCards{
			Edges: PlayerFavoriteCardsEdges{
				User: ViewUserAs(pfc.Edges.User, role),
				Card: ViewCardAs(pfc.Edges.Card, role),
			},
		}
	case public:
		return &PlayerFavoriteCards{
			Edges: PlayerFavoriteCardsEdges{
				User: ViewUserAs(pfc.Edges.User, role),
				Card: ViewCardAs(pfc.Edges.Card, role),
			},
		}
	case self:
		return &PlayerFavoriteCards{
			Edges: PlayerFavoriteCardsEdges{
				User: ViewUserAs(pfc.Edges.User, role),
				Card: ViewCardAs(pfc.Edges.Card, role),
			},
		}
	default:
		log.Fatalf("role not found to view PlayerFavoriteCards as %T", role)
	}

	return nil
}

func ViewPlayerFavoriteCardsListAs[K PlayerFavoriteCardsRoles](pfc []*PlayerFavoriteCards, role K) []*PlayerFavoriteCards {
	if len(pfc) == 0 {
		return nil
	}
	views := make([]*PlayerFavoriteCards, len(pfc))
	for i, v := range pfc {
		views[i] = ViewPlayerFavoriteCardsAs(v, role)
	}
	return views
}

type UserRoles interface {
	admin | public | self
}

func ViewUserAs[K UserRoles](u *User, role K) *User {
	if u == nil {
		return nil
	}

	switch any(role).(type) {
	case admin:
		return &User{
			ID:             u.ID,
			SelectedCardID: u.SelectedCardID,
			Edges: UserEdges{
				Cards:               ViewCardListAs(u.Edges.Cards, role),
				FavoriteCards:       ViewCardListAs(u.Edges.FavoriteCards, role),
				SelectedCard:        ViewCardAs(u.Edges.SelectedCard, role),
				PlayerFavoriteCards: ViewPlayerFavoriteCardsListAs(u.Edges.PlayerFavoriteCards, role),
			},
		}
	case public:
		return &User{
			SelectedCardID: u.SelectedCardID,
			Edges: UserEdges{
				Cards:               ViewCardListAs(u.Edges.Cards, role),
				FavoriteCards:       ViewCardListAs(u.Edges.FavoriteCards, role),
				SelectedCard:        ViewCardAs(u.Edges.SelectedCard, role),
				PlayerFavoriteCards: ViewPlayerFavoriteCardsListAs(u.Edges.PlayerFavoriteCards, role),
			},
		}
	case self:
		return &User{
			ID:             u.ID,
			SelectedCardID: u.SelectedCardID,
			Edges: UserEdges{
				Cards:               ViewCardListAs(u.Edges.Cards, role),
				FavoriteCards:       ViewCardListAs(u.Edges.FavoriteCards, role),
				SelectedCard:        ViewCardAs(u.Edges.SelectedCard, role),
				PlayerFavoriteCards: ViewPlayerFavoriteCardsListAs(u.Edges.PlayerFavoriteCards, role),
			},
		}
	default:
		log.Fatalf("role not found to view User as %T", role)
	}

	return nil
}

func ViewUserListAs[K UserRoles](u []*User, role K) []*User {
	if len(u) == 0 {
		return nil
	}
	views := make([]*User, len(u))
	for i, v := range u {
		views[i] = ViewUserAs(v, role)
	}
	return views
}
